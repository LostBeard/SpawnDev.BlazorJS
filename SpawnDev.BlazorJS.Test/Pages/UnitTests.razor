@using SpawnDev.Blazor.UnitTesting
@using System.Reflection

@page "/UnitTests"

<h3>Unit Tests for SpawnDev.BlazorJS</h3>
<p>
    This page runs tests to verify SpawnDev.BlazorJS is working as expected.
</p>

<UnitTestsView TypeInstanceResolver="TestTypeResolver" TestAssemblies="_assemblies" TestTypes="_types"></UnitTestsView>

@code {

    [Inject]
    BlazorJSRuntime JS { get; set; }

    [Inject]
    WebWorkerService _webWorkerService { get; set; }

    [Inject]
    IMathsService _mathService { get; set; }

    IEnumerable<Assembly>? _assemblies = new List<Assembly>();
    IEnumerable<Type>? _types = new List<Type>();

    protected override void OnInitialized()
    {
        _types = new List<Type> {
            this.GetType(),
        };
        _assemblies = new List<Assembly> {
            //typeof(UnitTestsView).Assembly,
            typeof(UnitTests).Assembly
        };
    }

    object? TestTypeResolver(Type testType)
    {
        if (testType == this.GetType()) return this;
        return null;
    }

    [TestMethod]
    public async Task WebWorkerAppSettingsReadTest()
    {
        if (!_webWorkerService.WebWorkerSupported)
        {
            throw new Exception("Worker not supported by browser. Expected failure.");
        }
        // test key to read from appsettings.json
        var testKey = "Message";
        // get value loaded in this context to compare to worker returned value
        var testValueWindow = await _mathService.ReadAppSettingsValue(testKey);
        // get worker and read the value fro mthat context
        using var worker = await _webWorkerService.GetWebWorker();
        var mathService = worker.GetService<IMathsService>();
        var testValueWorker = await mathService.ReadAppSettingsValue(testKey);
        // compare
        if (testValueWorker != testValueWindow) throw new Exception("Unexpected result");
        Console.WriteLine($"WebWorkerAppSettingsReadTest value: {testValueWorker}");
    }

    [TestMethod]
    public async Task WebWorkerTest()
    {
        if (!_webWorkerService.WebWorkerSupported)
        {
            throw new Exception("Worker not supported by browser. Expected failure.");
        }
        using var worker = await _webWorkerService.GetWebWorker();
        var mathService = worker.GetService<IMathsService>();
        var randValue = Guid.NewGuid().ToString();
        await mathService.SetValueTest(randValue);
        var readBack = await mathService.GetValueTest();
        if (readBack != randValue) throw new Exception("Unexpected result");
    }

    [TestMethod]
    public async Task WebWorkersTest()
    {
        if (!_webWorkerService.WebWorkerSupported)
        {
            throw new Exception("Worker not supported by browser. Expected failure.");
        }
        using var workerA = await _webWorkerService.GetWebWorker();
        using var workerB = await _webWorkerService.GetWebWorker();
        var mathServiceA = workerA.GetService<IMathsService>();
        var mathServiceB = workerB.GetService<IMathsService>();
        var randValue = Guid.NewGuid().ToString();
        await mathServiceA.SetValueTest(randValue);
        var readBack = await mathServiceB.GetValueTest();
        if (readBack == randValue) throw new Exception("Unexpected result");
    }

    [TestMethod]
    public async Task SharedWebWorkerTest()
    {
        if (!_webWorkerService.SharedWebWorkerSupported)
        {
            throw new Exception("SharedWorker not supported by browser. Expected failure.");
        }
        using var worker = await _webWorkerService.GetSharedWebWorker();
        var mathService = worker.GetService<IMathsService>();
        var randValue = Guid.NewGuid().ToString();
        await mathService.SetValueTest(randValue);
        var readBack = await mathService.GetValueTest();
        if (readBack != randValue) throw new Exception("Unexpected result");
    }

    [TestMethod]
    public async Task SharedWebWorkersByName()
    {
        if (!_webWorkerService.SharedWebWorkerSupported)
        {
            throw new Exception("SharedWorker not supported by browser. Expected failure.");
        }
        // workerA1 and workerA2 will refer to the same shared worker
        // workerB is a separate worker instance
        using var workerA1 = await _webWorkerService.GetSharedWebWorker("workerA");
        using var workerA2 = await _webWorkerService.GetSharedWebWorker("workerA");
        using var workerB = await _webWorkerService.GetSharedWebWorker("workerB");
        var mathServiceA1 = workerA1.GetService<IMathsService>();
        var mathServiceA2 = workerA2.GetService<IMathsService>();
        var mathServiceB = workerB.GetService<IMathsService>();
        var valueSetWorkerA1 = Guid.NewGuid().ToString();
        await mathServiceA1.SetValueTest(valueSetWorkerA1);
        var valueGetWorkerB = await mathServiceB.GetValueTest();
        var valueGetWorkerA1 = await mathServiceA1.GetValueTest();
        var valueGetWorkerA2 = await mathServiceA2.GetValueTest();
        if (valueGetWorkerA1 != valueSetWorkerA1) throw new Exception("Unexpected result");
        if (valueGetWorkerA2 != valueSetWorkerA1) throw new Exception("SharedWorker appears not shared");
        if (valueGetWorkerB == valueSetWorkerA1) throw new Exception("SharedWorker with different name unexpectedly same as first SharedWorker");
    }

    [TestMethod]
    public async Task SubtleCryptoRsaOaepEncryptDecryptTest()
    {
        if (!Crypto.IsSupported)
        {
            throw new Exception("Crypto not supported by browser.");
        }
        using var crypto = new Crypto();
        using var subtle = crypto.Subtle;
        var keyPair = await subtle.GenerateKey<CryptoKeyPair>(
            new RsaHashedKeyGenParams
                {
                    Name = "RSA-OAEP",
                    ModulusLength = 4096,
                    PublicExponent = new byte[] { 1, 0, 1 },
                    Hash = "SHA-256"
                },
            true,
            new string[] { "encrypt", "decrypt" }
        );
        var testString = "Hello Crypto!";
        var encryptedText = await EncryptDataWithPublicKey(testString, keyPair.PublicKey);
        var decryptedText = await DecryptDataWithPrivateKey(encryptedText, keyPair.PrivateKey);
        if (testString != decryptedText) throw new Exception("Unexpected result");

        // Now test exporting and then importing the private key (for testing only)
        // export private key
        var privateKey = await subtle.ExportKey<ArrayBuffer>("pkcs8", keyPair.PrivateKey);
        //var stringPublicKey = ArrayBufferToBase64(publicKey);
        // convert exported private key to a base64 string
        //var stringPrivateKey = ArrayBufferToBase64(privateKey);
        // convert base64 private key string to ArrayBuffer
        //var arrayBufferPrivateKey = Base6ToArrayBuffer4(stringPrivateKey);
        // import private key from ArrayBuffer

        JS.Log("_privateKey", privateKey);
        JS.Set("_privateKey", privateKey);

        var tmp = new RsaHashedImportParams { Name = "RSA-OAEP", Hash = "SHA-256" };

        JS.Log("_tmp", tmp);
        JS.Set("_tmp", tmp);

        subtle.ImportKeyTest("pkcs8", privateKey, new RsaHashedImportParams { Name = "RSA-OAEP", Hash = "SHA-256" }, true, new string[] { "decrypt" });
        // JS.Log("_privateKeyImported", privateKeyImported);
        // JS.Set("_privateKeyImported", privateKeyImported);


        // //var publicKey = await subtle.ExportKey<ArrayBuffer>("spki", keyPair.PublicKey);

        // var encryptedTextBase64 = ArrayBufferToBase64(encryptedText);
    }

    async Task<ArrayBuffer> EncryptDataWithPublicKey(string data, CryptoKey key)
    {
        using var crypto = new Crypto();
        using var subtle = crypto.Subtle;
        var dataAB = await StringToArrayBuffer(data);
        var ret = await subtle.Encrypt(new EncryptParams { Name = "RSA-OAEP" }, key, dataAB);
        return ret;
    }

    async Task<string> DecryptDataWithPrivateKey(ArrayBuffer data, CryptoKey key)
    {
        using var crypto = new Crypto();
        using var subtle = crypto.Subtle;
        var ret = await subtle.Decrypt(new EncryptParams { Name = "RSA-OAEP" }, key, data);
        var dataStr = await ArrayBufferToString(ret);
        return dataStr;
    }

    async Task<ArrayBuffer> StringToArrayBuffer(string data)
    {
        using var blob = new Blob(new string[] { data }, new BlobOptions { Type = "text/plain; charset=utf-8" });
        return await blob.ArrayBuffer();
    }

    async Task<string> ArrayBufferToString(ArrayBuffer data)
    {
        using var blob = new Blob(new ArrayBuffer[] { data });
        return await blob.Text();
    }

    string ArrayBufferToBase64(ArrayBuffer arrayBuffer)
    {
        var bytes = arrayBuffer.ReadBytes();
        return Convert.ToBase64String(bytes);
    }

    ArrayBuffer Base6ToArrayBuffer4(string base64String)
    {
        var bytes = Convert.FromBase64String(base64String);
        using var uint8Array = new Uint8Array(bytes);
        return uint8Array.Buffer;
    }
}